diff -N -r -U 3 icu-4.4.1-orig/source/tools/pkgdata/pkgdata.cpp icu-4.4.1/source/tools/pkgdata/pkgdata.cpp
--- icu-4.4.1-orig/source/tools/pkgdata/pkgdata.cpp	2010-04-28 18:27:46.000000000 +0300
+++ icu-4.4.1/source/tools/pkgdata/pkgdata.cpp	2010-08-19 15:14:18.000000000 +0300
@@ -98,6 +98,7 @@
 #endif
 
 #define LARGE_BUFFER_MAX_SIZE 2048
+#define MEDIUM_BUFFER_MAX_SIZE 1024
 #define SMALL_BUFFER_MAX_SIZE 512
 
 static void loadLists(UPKGOptions *o, UErrorCode *status);
@@ -110,6 +111,7 @@
 static int32_t pkg_createSymLinks(const char *targetDir, UBool specialHandling=FALSE);
 static int32_t pkg_installLibrary(const char *installDir, const char *dir);
 static int32_t pkg_installFileMode(const char *installDir, const char *srcDir, const char *fileListName);
+static int32_t pkg_installCommonMode(const char *installDir, const char *fileName);
 
 #ifdef BUILD_DATA_WITHOUT_ASSEMBLY
 static int32_t pkg_createWithoutAssemblyCode(UPKGOptions *o, const char *targetDir, const char mode);
@@ -119,6 +121,7 @@
 static int32_t pkg_generateLibraryFile(const char *targetDir, const char mode, const char *objectFile, char *command = NULL);
 static int32_t pkg_archiveLibrary(const char *targetDir, const char *version, UBool reverseExt);
 static void createFileNames(UPKGOptions *o, const char mode, const char *version_major, const char *version, const char *libName, const UBool reverseExt);
+static int32_t initializePkgDataFlags(UPKGOptions *o);
 
 static int32_t pkg_getOptionsFromICUConfig(UBool verbose, UOption *option);
 static int runCommand(const char* command, UBool specialHandling=FALSE);
@@ -472,29 +475,48 @@
 }
 
 static int runCommand(const char* command, UBool specialHandling) {
-    char cmd[SMALL_BUFFER_MAX_SIZE];
+    char *cmd = NULL;
+    char cmdBuffer[SMALL_BUFFER_MAX_SIZE];
+    int32_t len = strlen(command);
+
+    if (len == 0) {
+        return 0;
+    }
 
     if (!specialHandling) {
+#if defined(USING_CYGWIN) || defined(OS400)
+#define CMD_PADDING_SIZE 20
+        if ((len + CMD_PADDING_SIZE) >= SMALL_BUFFER_MAX_SIZE) {
+            cmd = (char *)uprv_malloc(len + CMD_PADDING_SIZE);
+        } else {
+            cmd = cmdBuffer;
+        }
 #ifdef USING_CYGWIN
         sprintf(cmd, "bash -c \"%s\"", command);
 
 #elif defined(OS400)
         sprintf(cmd, "QSH CMD('%s')", command);
+#endif
 #else
         goto normal_command_mode;
 #endif
     } else {
 normal_command_mode:
-        sprintf(cmd, "%s", command);
+        cmd = (char *)command;
     }
-    
+
     printf("pkgdata: %s\n", cmd);
     int result = system(cmd);
-    if (result != 0) { 
-        printf("-- return status = %d\n", result); 
+    if (result != 0) {
+        printf("-- return status = %d\n", result);
     }
-    return result; 
-} 
+
+    if (cmd != cmdBuffer && cmd != command) {
+        uprv_free(cmd);
+    }
+
+    return result;
+}
 
 #define LN_CMD "ln -s"
 #define RM_CMD "rm -f"
@@ -505,9 +527,8 @@
 #define MODE_FILES  'f'
 
 static int32_t pkg_executeOptions(UPKGOptions *o) {
-    UErrorCode status = U_ZERO_ERROR;
     int32_t result = 0;
-//    char cmd[SMALL_BUFFER_MAX_SIZE] = "";
+
     const char mode = o->mode[0];
     char targetDir[SMALL_BUFFER_MAX_SIZE] = "";
     char tmpDir[SMALL_BUFFER_MAX_SIZE] = "";
@@ -515,6 +536,8 @@
     char datFileNamePath[LARGE_BUFFER_MAX_SIZE] = "";
     char checkLibFile[LARGE_BUFFER_MAX_SIZE] = "";
 
+    initializePkgDataFlags(o);
+
     if (mode == MODE_FILES) {
         /* Copy the raw data to the installation directory. */
         if (o->install != NULL) {
@@ -576,48 +599,17 @@
                 fprintf(stderr, "Unable to move dat file (%s) to target location (%s).\n", datFileNamePath, targetFileNamePath);
             }
 
+            if (o->install != NULL) {
+                result = pkg_installCommonMode(o->install, targetFileNamePath);
+            }
+
             return result;
         } else /* if (mode[0] == MODE_STATIC || mode[0] == MODE_DLL) */ {
             char gencFilePath[SMALL_BUFFER_MAX_SIZE] = "";
             char version_major[10] = "";
             UBool reverseExt = FALSE;
 
-            /* Initialize pkgdataFlags */
-            pkgDataFlags = (char**)uprv_malloc(sizeof(char*) * PKGDATA_FLAGS_SIZE);
-            if (pkgDataFlags != NULL) {
-                for (int32_t i = 0; i < PKGDATA_FLAGS_SIZE; i++) {
-                    pkgDataFlags[i] = (char*)uprv_malloc(sizeof(char) * SMALL_BUFFER_MAX_SIZE);
-                    if (pkgDataFlags[i] != NULL) {
-                        pkgDataFlags[i][0] = 0;
-                    } else {
-                        fprintf(stderr,"Error allocating memory for pkgDataFlags.\n");
-                        return -1;
-                    }
-                }
-            } else {
-                fprintf(stderr,"Error allocating memory for pkgDataFlags.\n");
-                return -1;
-            }
-
-            if(o->verbose) {
-              fprintf(stdout, "# pkgDataFlags=");
-              for(int32_t i=0;i<PKGDATA_FLAGS_SIZE && pkgDataFlags[i][0];i++) {
-                fprintf(stdout, "%c \"%s\"", (i>0)?',':' ',pkgDataFlags[i]);
-              }
-              fprintf(stdout, "\n");
-            }
-
 #if !defined(WINDOWS_WITH_MSVC) || defined(USING_CYGWIN)
-            /* Read in options file. */
-            if(o->verbose) {
-              fprintf(stdout, "# Reading options file %s\n", o->options);
-            }
-            parseFlagsFile(o->options, pkgDataFlags, SMALL_BUFFER_MAX_SIZE, (int32_t)PKGDATA_FLAGS_SIZE, &status);
-            if (U_FAILURE(status)) {
-                fprintf(stderr,"Unable to open or read \"%s\" option file. status = %s\n", o->options, u_errorName(status));
-                return -1;
-            }
-
             /* Get the version major number. */
             if (o->version != NULL) {
                 for (uint32_t i = 0;i < sizeof(version_major);i++) {
@@ -755,6 +747,56 @@
     }
     return result;
 }
+
+/* Initialize the pkgDataFlags with the option file given. */
+static int32_t initializePkgDataFlags(UPKGOptions *o) {
+    UErrorCode status = U_ZERO_ERROR;
+    int32_t result = 0;
+    /* Initialize pkgdataFlags */
+    pkgDataFlags = (char**)uprv_malloc(sizeof(char*) * PKGDATA_FLAGS_SIZE);
+    if (pkgDataFlags != NULL) {
+        for (int32_t i = 0; i < PKGDATA_FLAGS_SIZE; i++) {
+            pkgDataFlags[i] = (char*)uprv_malloc(sizeof(char) * MEDIUM_BUFFER_MAX_SIZE);
+            if (pkgDataFlags[i] != NULL) {
+                pkgDataFlags[i][0] = 0;
+            } else {
+                fprintf(stderr,"Error allocating memory for pkgDataFlags.\n");
+                return -1;
+            }
+        }
+    } else {
+        fprintf(stderr,"Error allocating memory for pkgDataFlags.\n");
+        return -1;
+    }
+
+    if (o->options == NULL) {
+        return result;
+    }
+
+#if !defined(WINDOWS_WITH_MSVC) || defined(USING_CYGWIN)
+    /* Read in options file. */
+    if(o->verbose) {
+      fprintf(stdout, "# Reading options file %s\n", o->options);
+    }
+    parseFlagsFile(o->options, pkgDataFlags, SMALL_BUFFER_MAX_SIZE, (int32_t)PKGDATA_FLAGS_SIZE, &status);
+    if (U_FAILURE(status)) {
+        fprintf(stderr,"Unable to open or read \"%s\" option file. status = %s\n", o->options, u_errorName(status));
+        return -1;
+    }
+#endif
+
+    if(o->verbose) {
+        fprintf(stdout, "# pkgDataFlags=");
+        for(int32_t i=0;i<PKGDATA_FLAGS_SIZE && pkgDataFlags[i][0];i++) {
+            fprintf(stdout, "%c \"%s\"", (i>0)?',':' ',pkgDataFlags[i]);
+        }
+        fprintf(stdout, "\n");
+    }
+
+    return result;
+}
+
+
 /*
  * Given the base libName and version numbers, generate the libary file names and store it in libFileNames.
  * Depending on the configuration, the library name may either end with version number or shared object suffix.
@@ -831,7 +873,8 @@
 
 #ifndef USING_CYGWIN
     /* No symbolic link to make. */
-    if (uprv_strlen(libFileNames[LIB_FILE_VERSION]) == 0 || uprv_strlen(libFileNames[LIB_FILE_VERSION_MAJOR]) == 0) {
+    if (uprv_strlen(libFileNames[LIB_FILE_VERSION]) == 0 || uprv_strlen(libFileNames[LIB_FILE_VERSION_MAJOR]) == 0 ||
+        uprv_strcmp(libFileNames[LIB_FILE_VERSION], libFileNames[LIB_FILE_VERSION_MAJOR]) == 0) {
         return result;
     }
     
@@ -920,6 +963,33 @@
     return pkg_createSymLinks(installDir, TRUE);
 }
 
+static int32_t pkg_installCommonMode(const char *installDir, const char *fileName) {
+    int32_t result = 0;
+    char cmd[SMALL_BUFFER_MAX_SIZE] = "";
+
+    if (!T_FileStream_file_exists(installDir)) {
+        UErrorCode status = U_ZERO_ERROR;
+
+        uprv_mkdir(installDir, &status);
+        if (U_FAILURE(status)) {
+            fprintf(stderr, "Error creating installation directory: %s\n", installDir);
+            return -1;
+        }
+    }
+#ifndef U_WINDOWS_WITH_MSVC
+    sprintf(cmd, "%s %s %s", pkgDataFlags[INSTALL_CMD], fileName, installDir);
+#else
+    sprintf(cmd, "%s %s %s %s", WIN_INSTALL_CMD, fileName, installDir, WIN_INSTALL_CMD_FLAGS);
+#endif
+
+    result = runCommand(cmd);
+    if (result != 0) {
+        fprintf(stderr, "Failed to install data file with command: %s\n", cmd);
+    }
+
+    return result;
+}
+
 #ifdef U_WINDOWS_MSVC
 /* Copy commands for installing the raw data files on Windows. */
 #define WIN_INSTALL_CMD "xcopy"
@@ -1366,6 +1436,7 @@
         char dllFilePath[SMALL_BUFFER_MAX_SIZE] = "";
         char libFilePath[SMALL_BUFFER_MAX_SIZE] = "";
         char resFilePath[SMALL_BUFFER_MAX_SIZE] = "";
+        char tmpResFilePath[SMALL_BUFFER_MAX_SIZE] = "";
 
 #ifdef CYGWINMSVC
         uprv_strcpy(dllFilePath, o->targetDir);
@@ -1382,18 +1453,22 @@
         uprv_strcat(dllFilePath, o->libName);
         uprv_strcat(dllFilePath, o->version);
 #else
+        if (strstr(o->libName, "icudt")) {
+            uprv_strcat(libFilePath, LIB_FILE);
+        } else {
+            uprv_strcat(libFilePath, o->libName);
+            uprv_strcat(libFilePath, ".lib");
+        }
         uprv_strcat(dllFilePath, o->entryName);
-        
-        uprv_strcat(libFilePath, LIB_FILE);
 #endif
         uprv_strcat(dllFilePath, DLL_EXT);
         
-        uprv_strcpy(resFilePath, o->tmpDir);
-        uprv_strcat(resFilePath, PKGDATA_FILE_SEP_STRING);
-        uprv_strcat(resFilePath, ICUDATA_RES_FILE);
+        uprv_strcpy(tmpResFilePath, o->tmpDir);
+        uprv_strcat(tmpResFilePath, PKGDATA_FILE_SEP_STRING);
+        uprv_strcat(tmpResFilePath, ICUDATA_RES_FILE);
 
-        if (!T_FileStream_file_exists(resFilePath)) {
-            uprv_memset(resFilePath, 0, sizeof(resFilePath));
+        if (T_FileStream_file_exists(tmpResFilePath)) {
+            sprintf(resFilePath, "\"%s\"", tmpResFilePath);
         }
 
         /* Check if dll file and lib file exists and that it is not newer than genc file. */
@@ -1405,7 +1480,7 @@
           return 0;
         }
 
-        sprintf(cmd, "%s\"%s\" %s\"%s\" \"%s\" \"%s\"",
+        sprintf(cmd, "%s\"%s\" %s\"%s\" \"%s\" %s",
                 LINK_CMD,
                 dllFilePath,
                 LINK_FLAGS,
